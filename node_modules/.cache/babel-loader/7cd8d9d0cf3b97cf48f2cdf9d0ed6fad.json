{"ast":null,"code":"import \"core-js/modules/es.error.cause.js\";\nimport { onMounted, ref, markRaw, readonly, defineAsyncComponent, nextTick, getCurrentInstance } from \"vue\";\nimport { ComponentContainer, LayoutConfig, RowOrColumnItemConfig, StackItemConfig, ComponentItemConfig, ResolvedComponentItemConfig, LogicalZIndex, VirtualLayout, ResolvedLayoutConfig } from \"golden-layout\";\nimport GlComponent from \"@/components/GlComponent.vue\";\n/*******************\n * Prop\n *******************/\n\nexport default {\n  props: {\n    glcPath: String\n  },\n\n  setup(__props, {\n    expose\n  }) {\n    const props = __props;\n    /*******************\n     * Data\n     *******************/\n\n    const GLRoot = ref(null);\n    let GLayout;\n    const GlcKeyPrefix = readonly(ref(\"glc_\"));\n    const MapComponents = new Map();\n    const AllComponents = ref(new Map());\n    const UnusedIndexes = [];\n    let CurIndex = 0;\n    let GlBoundingClientRect;\n    const instance = getCurrentInstance();\n    /*******************\n     * Method\n     *******************/\n\n    /** @internal */\n\n    const addComponent = (componentType, title) => {\n      const glc = markRaw(defineAsyncComponent(() => import(props.glcPath + componentType + \".vue\")));\n      let index = CurIndex;\n      if (UnusedIndexes.length > 0) index = UnusedIndexes.pop();else CurIndex++;\n      AllComponents.value.set(index, glc);\n      return index;\n    };\n\n    const addGLComponent = async (componentType, title) => {\n      if (componentType.length == 0) throw new Error(\"addGLComponent: Component's type is empty\");\n      const index = addComponent(componentType, title);\n      await nextTick(); // wait 1 tick for vue to add the dom\n\n      GLayout.addComponent(componentType, {\n        refId: index\n      }, title);\n    };\n\n    const loadGLLayout = async layoutConfig => {\n      GLayout.clear();\n      AllComponents.value.clear();\n      const config = layoutConfig.resolved ? LayoutConfig.fromResolved(layoutConfig) : layoutConfig;\n      let contents = [config.root.content];\n      let index = 0;\n\n      while (contents.length > 0) {\n        const content = contents.shift();\n\n        for (let itemConfig of content) {\n          if (itemConfig.type == \"component\") {\n            index = addComponent(itemConfig.componentType, itemConfig.title);\n            if (typeof itemConfig.componentState == \"object\") itemConfig.componentState[\"refId\"] = index;else itemConfig.componentState = {\n              refId: index\n            };\n          } else if (itemConfig.content.length > 0) {\n            contents.push(itemConfig.content);\n          }\n        }\n      }\n\n      await nextTick(); // wait 1 tick for vue to add the dom\n\n      GLayout.loadLayout(config);\n    };\n\n    const getLayoutConfig = () => {\n      return GLayout.saveLayout();\n    };\n    /*******************\n     * Mount\n     *******************/\n\n\n    onMounted(() => {\n      if (GLRoot.value == null) throw new Error(\"Golden Layout can't find the root DOM!\");\n\n      const onResize = () => {\n        const dom = GLRoot.value;\n        let width = dom ? dom.offsetWidth : 0;\n        let height = dom ? dom.offsetHeight : 0;\n        GLayout.setSize(width, height);\n      };\n\n      window.addEventListener(\"resize\", onResize, {\n        passive: true\n      });\n\n      const handleBeforeVirtualRectingEvent = count => {\n        GlBoundingClientRect = GLRoot.value.getBoundingClientRect();\n      };\n\n      const handleContainerVirtualRectingRequiredEvent = (container, width, height) => {\n        const component = MapComponents.get(container);\n\n        if (!component || !component?.glc) {\n          throw new Error(\"handleContainerVirtualRectingRequiredEvent: Component not found\");\n        }\n\n        const containerBoundingClientRect = container.element.getBoundingClientRect();\n        const left = containerBoundingClientRect.left - GlBoundingClientRect.left;\n        const top = containerBoundingClientRect.top - GlBoundingClientRect.top;\n        component.glc.setPosAndSize(left, top, width, height);\n      };\n\n      const handleContainerVirtualVisibilityChangeRequiredEvent = (container, visible) => {\n        const component = MapComponents.get(container);\n\n        if (!component || !component?.glc) {\n          throw new Error(\"handleContainerVirtualVisibilityChangeRequiredEvent: Component not found\");\n        }\n\n        component.glc.setVisibility(visible);\n      };\n\n      const handleContainerVirtualZIndexChangeRequiredEvent = (container, logicalZIndex, defaultZIndex) => {\n        const component = MapComponents.get(container);\n\n        if (!component || !component?.glc) {\n          throw new Error(\"handleContainerVirtualZIndexChangeRequiredEvent: Component not found\");\n        }\n\n        component.glc.setZIndex(defaultZIndex);\n      };\n\n      const bindComponentEventListener = (container, itemConfig) => {\n        let refId = -1;\n\n        if (itemConfig && itemConfig.componentState) {\n          refId = itemConfig.componentState.refId;\n        } else {\n          throw new Error(\"bindComponentEventListener: component's ref id is required\");\n        }\n\n        const ref = GlcKeyPrefix.value + refId;\n        const component = instance?.refs[ref][0];\n        console.log(component);\n        MapComponents.set(container, {\n          refId: refId,\n          glc: component\n        });\n\n        container.virtualRectingRequiredEvent = (container, width, height) => handleContainerVirtualRectingRequiredEvent(container, width, height);\n\n        container.virtualVisibilityChangeRequiredEvent = (container, visible) => handleContainerVirtualVisibilityChangeRequiredEvent(container, visible);\n\n        container.virtualZIndexChangeRequiredEvent = (container, logicalZIndex, defaultZIndex) => handleContainerVirtualZIndexChangeRequiredEvent(container, logicalZIndex, defaultZIndex);\n\n        return {\n          component,\n          virtual: true\n        };\n      };\n\n      const unbindComponentEventListener = container => {\n        const component = MapComponents.get(container);\n\n        if (!component || !component?.glc) {\n          throw new Error(\"handleUnbindComponentEvent: Component not found\");\n        }\n\n        MapComponents.delete(container);\n        AllComponents.value.delete(component.refId);\n        UnusedIndexes.push(component.refId);\n      };\n\n      GLayout = new VirtualLayout(GLRoot.value, bindComponentEventListener, unbindComponentEventListener);\n      GLayout.beforeVirtualRectingEvent = handleBeforeVirtualRectingEvent;\n    });\n    /*******************\n     * Expose\n     *******************/\n\n    expose({\n      addGLComponent,\n      loadGLLayout,\n      getLayoutConfig\n    });\n    const __returned__ = {\n      props,\n      GLRoot,\n      GLayout,\n      GlcKeyPrefix,\n      MapComponents,\n      AllComponents,\n      UnusedIndexes,\n      CurIndex,\n      GlBoundingClientRect,\n      instance,\n      addComponent,\n      addGLComponent,\n      loadGLLayout,\n      getLayoutConfig,\n      onMounted,\n      ref,\n      markRaw,\n      readonly,\n      defineAsyncComponent,\n      nextTick,\n      getCurrentInstance,\n      ComponentContainer,\n      LayoutConfig,\n      RowOrColumnItemConfig,\n      StackItemConfig,\n      ComponentItemConfig,\n      ResolvedComponentItemConfig,\n      LogicalZIndex,\n      VirtualLayout,\n      ResolvedLayoutConfig,\n      GlComponent\n    };\n    Object.defineProperty(__returned__, '__isScriptSetup', {\n      enumerable: false,\n      value: true\n    });\n    return __returned__;\n  }\n\n};","map":{"version":3,"mappings":";AAkBA,SACIA,SADJ,EAEIC,GAFJ,EAGIC,OAHJ,EAIIC,QAJJ,EAMIC,oBANJ,EAQIC,QARJ,EASIC,kBATJ,QAUO,KAVP;AAWA,SACIC,kBADJ,EAEIC,YAFJ,EAGIC,qBAHJ,EAIIC,eAJJ,EAKIC,mBALJ,EAMIC,2BANJ,EAOIC,aAPJ,EAQIC,aARJ,EASIC,oBATJ,QAUO,eAVP;AAWA,OAAOC,WAAP,MAAwB,8BAAxB;AAEA;AACA;AACA;;;;;;;;;;;AAKA;AACA;AACA;;AACA,UAAMC,MAAM,GAAGhB,GAAG,CAAC,IAAD,CAAlB;AACA,QAAIiB,OAAJ;AACA,UAAMC,YAAY,GAAGhB,QAAQ,CAACF,GAAG,CAAC,MAAD,CAAJ,CAA7B;AAEA,UAAMmB,aAAa,GAAG,IAAIC,GAAJ,EAAtB;AAEA,UAAMC,aAAa,GAAGrB,GAAG,CAAC,IAAIoB,GAAJ,EAAD,CAAzB;AACA,UAAME,aAAa,GAAG,EAAtB;AACA,QAAIC,QAAQ,GAAG,CAAf;AACA,QAAIC,oBAAJ;AAEA,UAAMC,QAAQ,GAAGpB,kBAAkB,EAAnC;AAEA;AACA;AACA;;AACA;;AACA,UAAMqB,YAAY,GAAG,CAACC,aAAD,EAAgBC,KAAhB,KAA0B;AAC3C,YAAMC,GAAG,GAAG5B,OAAO,CACfE,oBAAoB,CAChB,MAAM,OAAO2B,KAAK,CAACC,OAAN,GAAgBJ,aAAhB,GAAgC,MAAvC,CADU,CADL,CAAnB;AAMA,UAAIK,KAAK,GAAGT,QAAZ;AACA,UAAID,aAAa,CAACW,MAAd,GAAuB,CAA3B,EAA8BD,KAAK,GAAGV,aAAa,CAACY,GAAd,EAAR,CAA9B,KACKX,QAAQ;AAEbF,mBAAa,CAACc,KAAd,CAAoBC,GAApB,CAAwBJ,KAAxB,EAA+BH,GAA/B;AAEA,aAAOG,KAAP;AACH,KAdD;;AAgBA,UAAMK,cAAc,GAAG,OAAOV,aAAP,EAAsBC,KAAtB,KAAgC;AACnD,UAAID,aAAa,CAACM,MAAd,IAAwB,CAA5B,EACI,MAAM,IAAIK,KAAJ,CAAU,2CAAV,CAAN;AAEJ,YAAMN,KAAK,GAAGN,YAAY,CAACC,aAAD,EAAgBC,KAAhB,CAA1B;AAEA,YAAMxB,QAAQ,EAAd,CANmD,CAMjC;;AAElBa,aAAO,CAACS,YAAR,CAAqBC,aAArB,EAAoC;AAAEY,aAAK,EAAEP;AAAT,OAApC,EAAsDJ,KAAtD;AACH,KATD;;AAWA,UAAMY,YAAY,GAAG,MACjBC,YADiB,IAEhB;AACDxB,aAAO,CAACyB,KAAR;AACArB,mBAAa,CAACc,KAAd,CAAoBO,KAApB;AAEA,YAAMC,MAAM,GACRF,YAAY,CAACG,QAAb,GACMrC,YAAY,CAACsC,YAAb,CAA0BJ,YAA1B,CADN,GAEMA,YAHV;AAMA,UAAIK,QAAQ,GAAG,CAACH,MAAM,CAACI,IAAP,CAAYC,OAAb,CAAf;AAEA,UAAIhB,KAAK,GAAG,CAAZ;;AACA,aAAOc,QAAQ,CAACb,MAAT,GAAkB,CAAzB,EAA4B;AACxB,cAAMe,OAAO,GAAGF,QAAQ,CAACG,KAAT,EAAhB;;AACA,aAAK,IAAIC,UAAT,IAAuBF,OAAvB,EAAgC;AAC5B,cAAIE,UAAU,CAACC,IAAX,IAAmB,WAAvB,EAAoC;AAChCnB,iBAAK,GAAGN,YAAY,CAChBwB,UAAU,CAACvB,aADK,EAEhBuB,UAAU,CAACtB,KAFK,CAApB;AAIA,gBAAI,OAAOsB,UAAU,CAACE,cAAlB,IAAoC,QAAxC,EACIF,UAAU,CAACE,cAAX,CAA0B,OAA1B,IAAqCpB,KAArC,CADJ,KAEKkB,UAAU,CAACE,cAAX,GAA4B;AAAEb,mBAAK,EAAEP;AAAT,aAA5B;AACR,WARD,MAQO,IAAIkB,UAAU,CAACF,OAAX,CAAmBf,MAAnB,GAA4B,CAAhC,EAAmC;AACtCa,oBAAQ,CAACO,IAAT,CACIH,UAAU,CAACF,OADf;AAGH;AACJ;AACJ;;AAED,YAAM5C,QAAQ,EAAd,CAhCC,CAgCiB;;AAElBa,aAAO,CAACqC,UAAR,CAAmBX,MAAnB;AACH,KArCD;;AAuCA,UAAMY,eAAe,GAAG,MAAM;AAC1B,aAAOtC,OAAO,CAACuC,UAAR,EAAP;AACH,KAFD;AAIA;AACA;AACA;;;AACAzD,aAAS,CAAC,MAAM;AACZ,UAAIiB,MAAM,CAACmB,KAAP,IAAgB,IAApB,EACI,MAAM,IAAIG,KAAJ,CAAU,wCAAV,CAAN;;AAEJ,YAAMmB,QAAQ,GAAG,MAAM;AACnB,cAAMC,GAAG,GAAG1C,MAAM,CAACmB,KAAnB;AACA,YAAIwB,KAAK,GAAGD,GAAG,GAAGA,GAAG,CAACE,WAAP,GAAqB,CAApC;AACA,YAAIC,MAAM,GAAGH,GAAG,GAAGA,GAAG,CAACI,YAAP,GAAsB,CAAtC;AACA7C,eAAO,CAAC8C,OAAR,CAAgBJ,KAAhB,EAAuBE,MAAvB;AACH,OALD;;AAOAG,YAAM,CAACC,gBAAP,CAAwB,QAAxB,EAAkCR,QAAlC,EAA4C;AAAES,eAAO,EAAE;AAAX,OAA5C;;AAEA,YAAMC,+BAA+B,GAAIC,KAAD,IAAW;AAC/C5C,4BAAoB,GAChBR,MAAM,CAACmB,KADY,CAErBkC,qBAFqB,EAAvB;AAGH,OAJD;;AAMA,YAAMC,0CAA0C,GAAG,CAC/CC,SAD+C,EAE/CZ,KAF+C,EAG/CE,MAH+C,KAI9C;AACD,cAAMW,SAAS,GAAGrD,aAAa,CAACsD,GAAd,CAAkBF,SAAlB,CAAlB;;AACA,YAAI,CAACC,SAAD,IAAc,CAACA,SAAS,EAAE3C,GAA9B,EAAmC;AAC/B,gBAAM,IAAIS,KAAJ,CACF,iEADE,CAAN;AAGH;;AAED,cAAMoC,2BAA2B,GAC7BH,SAAS,CAACI,OAAV,CAAkBN,qBAAlB,EADJ;AAEA,cAAMO,IAAI,GACNF,2BAA2B,CAACE,IAA5B,GAAmCpD,oBAAoB,CAACoD,IAD5D;AAEA,cAAMC,GAAG,GAAGH,2BAA2B,CAACG,GAA5B,GAAkCrD,oBAAoB,CAACqD,GAAnE;AACAL,iBAAS,CAAC3C,GAAV,CAAciD,aAAd,CAA4BF,IAA5B,EAAkCC,GAAlC,EAAuClB,KAAvC,EAA8CE,MAA9C;AACH,OAlBD;;AAoBA,YAAMkB,mDAAmD,GAAG,CACxDR,SADwD,EAExDS,OAFwD,KAGvD;AACD,cAAMR,SAAS,GAAGrD,aAAa,CAACsD,GAAd,CAAkBF,SAAlB,CAAlB;;AACA,YAAI,CAACC,SAAD,IAAc,CAACA,SAAS,EAAE3C,GAA9B,EAAmC;AAC/B,gBAAM,IAAIS,KAAJ,CACF,0EADE,CAAN;AAGH;;AAEDkC,iBAAS,CAAC3C,GAAV,CAAcoD,aAAd,CAA4BD,OAA5B;AACH,OAZD;;AAcA,YAAME,+CAA+C,GAAG,CACpDX,SADoD,EAEpDY,aAFoD,EAGpDC,aAHoD,KAInD;AACD,cAAMZ,SAAS,GAAGrD,aAAa,CAACsD,GAAd,CAAkBF,SAAlB,CAAlB;;AACA,YAAI,CAACC,SAAD,IAAc,CAACA,SAAS,EAAE3C,GAA9B,EAAmC;AAC/B,gBAAM,IAAIS,KAAJ,CACF,sEADE,CAAN;AAGH;;AAEDkC,iBAAS,CAAC3C,GAAV,CAAcwD,SAAd,CAAwBD,aAAxB;AACH,OAbD;;AAeA,YAAME,0BAA0B,GAAG,CAC/Bf,SAD+B,EAE/BrB,UAF+B,KAG9B;AACD,YAAIX,KAAK,GAAG,CAAC,CAAb;;AACA,YAAIW,UAAU,IAAIA,UAAU,CAACE,cAA7B,EAA6C;AACzCb,eAAK,GAAIW,UAAU,CAACE,cAAZ,CAA4Bb,KAApC;AACH,SAFD,MAEO;AACH,gBAAM,IAAID,KAAJ,CACF,4DADE,CAAN;AAGH;;AAED,cAAMtC,GAAG,GAAGkB,YAAY,CAACiB,KAAb,GAAqBI,KAAjC;AACA,cAAMiC,SAAS,GAAG/C,QAAQ,EAAE8D,IAAV,CAAevF,GAAf,EAAoB,CAApB,CAAlB;AACAwF,eAAO,CAACC,GAAR,CAAYjB,SAAZ;AAEArD,qBAAa,CAACiB,GAAd,CAAkBmC,SAAlB,EAA6B;AAAEhC,eAAK,EAAEA,KAAT;AAAgBV,aAAG,EAAE2C;AAArB,SAA7B;;AAEAD,iBAAS,CAACmB,2BAAV,GAAwC,CAACnB,SAAD,EAAYZ,KAAZ,EAAmBE,MAAnB,KACpCS,0CAA0C,CACtCC,SADsC,EAEtCZ,KAFsC,EAGtCE,MAHsC,CAD9C;;AAOAU,iBAAS,CAACoB,oCAAV,GAAiD,CAACpB,SAAD,EAAYS,OAAZ,KAC7CD,mDAAmD,CAC/CR,SAD+C,EAE/CS,OAF+C,CADvD;;AAMAT,iBAAS,CAACqB,gCAAV,GAA6C,CACzCrB,SADyC,EAEzCY,aAFyC,EAGzCC,aAHyC,KAKzCF,+CAA+C,CAC3CX,SAD2C,EAE3CY,aAF2C,EAG3CC,aAH2C,CALnD;;AAWA,eAAO;AACHZ,mBADG;AAEHqB,iBAAO,EAAE;AAFN,SAAP;AAIH,OA/CD;;AAiDA,YAAMC,4BAA4B,GAC9BvB,SADiC,IAEhC;AACD,cAAMC,SAAS,GAAGrD,aAAa,CAACsD,GAAd,CAAkBF,SAAlB,CAAlB;;AACA,YAAI,CAACC,SAAD,IAAc,CAACA,SAAS,EAAE3C,GAA9B,EAAmC;AAC/B,gBAAM,IAAIS,KAAJ,CAAU,iDAAV,CAAN;AACH;;AAEDnB,qBAAa,CAAC4E,MAAd,CAAqBxB,SAArB;AACAlD,qBAAa,CAACc,KAAd,CAAoB4D,MAApB,CAA2BvB,SAAS,CAACjC,KAArC;AACAjB,qBAAa,CAAC+B,IAAd,CAAmBmB,SAAS,CAACjC,KAA7B;AACH,OAXD;;AAaAtB,aAAO,GAAG,IAAIJ,aAAJ,CACNG,MAAM,CAACmB,KADD,EAENmD,0BAFM,EAGNQ,4BAHM,CAAV;AAMA7E,aAAO,CAAC+E,yBAAR,GAAoC7B,+BAApC;AACH,KAzIQ,CAAT;AA2IA;AACA;AACA;;AACA8B,UAAY,CAAC;AACT5D,oBADS;AAETG,kBAFS;AAGTe;AAHS,KAAD,CAAZ","names":["onMounted","ref","markRaw","readonly","defineAsyncComponent","nextTick","getCurrentInstance","ComponentContainer","LayoutConfig","RowOrColumnItemConfig","StackItemConfig","ComponentItemConfig","ResolvedComponentItemConfig","LogicalZIndex","VirtualLayout","ResolvedLayoutConfig","GlComponent","GLRoot","GLayout","GlcKeyPrefix","MapComponents","Map","AllComponents","UnusedIndexes","CurIndex","GlBoundingClientRect","instance","addComponent","componentType","title","glc","props","glcPath","index","length","pop","value","set","addGLComponent","Error","refId","loadGLLayout","layoutConfig","clear","config","resolved","fromResolved","contents","root","content","shift","itemConfig","type","componentState","push","loadLayout","getLayoutConfig","saveLayout","onResize","dom","width","offsetWidth","height","offsetHeight","setSize","window","addEventListener","passive","handleBeforeVirtualRectingEvent","count","getBoundingClientRect","handleContainerVirtualRectingRequiredEvent","container","component","get","containerBoundingClientRect","element","left","top","setPosAndSize","handleContainerVirtualVisibilityChangeRequiredEvent","visible","setVisibility","handleContainerVirtualZIndexChangeRequiredEvent","logicalZIndex","defaultZIndex","setZIndex","bindComponentEventListener","refs","console","log","virtualRectingRequiredEvent","virtualVisibilityChangeRequiredEvent","virtualZIndexChangeRequiredEvent","virtual","unbindComponentEventListener","delete","beforeVirtualRectingEvent","expose"],"sources":["/Users/mengxia/Documents/ctat_vue3/src/components/Glayout.vue"],"sourcesContent":["<template>\n    <div style=\"position: relative\">\n        <div ref=\"GLRoot\" style=\"position: absolute; width: 100%; height: 100%\">\n            <!-- Root dom for Golden-Layout manager -->\n        </div>\n        <div style=\"position: absolute; width: 100%; height: 100%\">\n            <gl-component\n                v-for=\"pair in AllComponents\"\n                :key=\"pair[0]\"\n                :ref=\"GlcKeyPrefix + pair[0]\"\n            >\n                <component :is=\"pair[1]\"></component>\n            </gl-component>\n        </div>\n    </div>\n</template>\n\n<script setup>\nimport {\n    onMounted,\n    ref,\n    markRaw,\n    readonly,\n    defineExpose,\n    defineAsyncComponent,\n    defineProps,\n    nextTick,\n    getCurrentInstance,\n} from \"vue\";\nimport {\n    ComponentContainer,\n    LayoutConfig,\n    RowOrColumnItemConfig,\n    StackItemConfig,\n    ComponentItemConfig,\n    ResolvedComponentItemConfig,\n    LogicalZIndex,\n    VirtualLayout,\n    ResolvedLayoutConfig,\n} from \"golden-layout\";\nimport GlComponent from \"@/components/GlComponent.vue\";\n\n/*******************\n * Prop\n *******************/\nconst props = defineProps({\n    glcPath: String,\n});\n\n/*******************\n * Data\n *******************/\nconst GLRoot = ref(null);\nlet GLayout;\nconst GlcKeyPrefix = readonly(ref(\"glc_\"));\n\nconst MapComponents = new Map();\n\nconst AllComponents = ref(new Map());\nconst UnusedIndexes = [];\nlet CurIndex = 0;\nlet GlBoundingClientRect;\n\nconst instance = getCurrentInstance();\n\n/*******************\n * Method\n *******************/\n/** @internal */\nconst addComponent = (componentType, title) => {\n    const glc = markRaw(\n        defineAsyncComponent(\n            () => import(props.glcPath + componentType + \".vue\")\n        )\n    );\n\n    let index = CurIndex;\n    if (UnusedIndexes.length > 0) index = UnusedIndexes.pop();\n    else CurIndex++;\n\n    AllComponents.value.set(index, glc);\n\n    return index;\n};\n\nconst addGLComponent = async (componentType, title) => {\n    if (componentType.length == 0)\n        throw new Error(\"addGLComponent: Component's type is empty\");\n\n    const index = addComponent(componentType, title);\n\n    await nextTick(); // wait 1 tick for vue to add the dom\n\n    GLayout.addComponent(componentType, { refId: index }, title);\n};\n\nconst loadGLLayout = async (\n    layoutConfig\n) => {\n    GLayout.clear();\n    AllComponents.value.clear();\n\n    const config = (\n        layoutConfig.resolved\n            ? LayoutConfig.fromResolved(layoutConfig)\n            : layoutConfig\n    );\n\n    let contents = [config.root.content];\n\n    let index = 0;\n    while (contents.length > 0) {\n        const content = contents.shift();\n        for (let itemConfig of content) {\n            if (itemConfig.type == \"component\") {\n                index = addComponent(\n                    itemConfig.componentType,\n                    itemConfig.title\n                );\n                if (typeof itemConfig.componentState == \"object\")\n                    itemConfig.componentState[\"refId\"] = index;\n                else itemConfig.componentState = { refId: index };\n            } else if (itemConfig.content.length > 0) {\n                contents.push(\n                    itemConfig.content\n                );\n            }\n        }\n    }\n\n    await nextTick(); // wait 1 tick for vue to add the dom\n\n    GLayout.loadLayout(config);\n};\n\nconst getLayoutConfig = () => {\n    return GLayout.saveLayout();\n};\n\n/*******************\n * Mount\n *******************/\nonMounted(() => {\n    if (GLRoot.value == null)\n        throw new Error(\"Golden Layout can't find the root DOM!\");\n\n    const onResize = () => {\n        const dom = GLRoot.value;\n        let width = dom ? dom.offsetWidth : 0;\n        let height = dom ? dom.offsetHeight : 0;\n        GLayout.setSize(width, height);\n    };\n\n    window.addEventListener(\"resize\", onResize, { passive: true });\n\n    const handleBeforeVirtualRectingEvent = (count) => {\n        GlBoundingClientRect = (\n            GLRoot.value\n        ).getBoundingClientRect();\n    };\n\n    const handleContainerVirtualRectingRequiredEvent = (\n        container,\n        width,\n        height\n    ) => {\n        const component = MapComponents.get(container);\n        if (!component || !component?.glc) {\n            throw new Error(\n                \"handleContainerVirtualRectingRequiredEvent: Component not found\"\n            );\n        }\n\n        const containerBoundingClientRect =\n            container.element.getBoundingClientRect();\n        const left =\n            containerBoundingClientRect.left - GlBoundingClientRect.left;\n        const top = containerBoundingClientRect.top - GlBoundingClientRect.top;\n        component.glc.setPosAndSize(left, top, width, height);\n    };\n\n    const handleContainerVirtualVisibilityChangeRequiredEvent = (\n        container,\n        visible\n    ) => {\n        const component = MapComponents.get(container);\n        if (!component || !component?.glc) {\n            throw new Error(\n                \"handleContainerVirtualVisibilityChangeRequiredEvent: Component not found\"\n            );\n        }\n\n        component.glc.setVisibility(visible);\n    };\n\n    const handleContainerVirtualZIndexChangeRequiredEvent = (\n        container,\n        logicalZIndex,\n        defaultZIndex\n    ) => {\n        const component = MapComponents.get(container);\n        if (!component || !component?.glc) {\n            throw new Error(\n                \"handleContainerVirtualZIndexChangeRequiredEvent: Component not found\"\n            );\n        }\n\n        component.glc.setZIndex(defaultZIndex);\n    };\n\n    const bindComponentEventListener = (\n        container,\n        itemConfig\n    ) => {\n        let refId = -1;\n        if (itemConfig && itemConfig.componentState) {\n            refId = (itemConfig.componentState).refId;\n        } else {\n            throw new Error(\n                \"bindComponentEventListener: component's ref id is required\"\n            );\n        }\n\n        const ref = GlcKeyPrefix.value + refId;\n        const component = instance?.refs[ref][0];\n        console.log(component)\n\n        MapComponents.set(container, { refId: refId, glc: component });\n\n        container.virtualRectingRequiredEvent = (container, width, height) =>\n            handleContainerVirtualRectingRequiredEvent(\n                container,\n                width,\n                height\n            );\n\n        container.virtualVisibilityChangeRequiredEvent = (container, visible) =>\n            handleContainerVirtualVisibilityChangeRequiredEvent(\n                container,\n                visible\n            );\n\n        container.virtualZIndexChangeRequiredEvent = (\n            container,\n            logicalZIndex,\n            defaultZIndex\n        ) =>\n            handleContainerVirtualZIndexChangeRequiredEvent(\n                container,\n                logicalZIndex,\n                defaultZIndex\n            );\n\n        return {\n            component,\n            virtual: true,\n        };\n    };\n\n    const unbindComponentEventListener = (\n        container\n    ) => {\n        const component = MapComponents.get(container);\n        if (!component || !component?.glc) {\n            throw new Error(\"handleUnbindComponentEvent: Component not found\");\n        }\n\n        MapComponents.delete(container);\n        AllComponents.value.delete(component.refId);\n        UnusedIndexes.push(component.refId);\n    };\n\n    GLayout = new VirtualLayout(\n        GLRoot.value,\n        bindComponentEventListener,\n        unbindComponentEventListener\n    );\n\n    GLayout.beforeVirtualRectingEvent = handleBeforeVirtualRectingEvent;\n});\n\n/*******************\n * Expose\n *******************/\ndefineExpose({\n    addGLComponent,\n    loadGLLayout,\n    getLayoutConfig,\n});\n</script>\n"]},"metadata":{},"sourceType":"module"}